from gi.repository import GObject, Gtk
from gi.repository import Pango
from mykiss import LogObject
from mykiss import Document
from mykiss.widgets import View


class Editor(Gtk.Paned, LogObject):
    __gsignals__ = {
        "active-document-changed": (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,
                                   (GObject.TYPE_PYOBJECT,)),
        "document-added":          (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,
                                   (GObject.TYPE_PYOBJECT,)),
        "document-removed":        (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,
                                   (GObject.TYPE_PYOBJECT,)),
    }
    def __init__(self):
        LogObject.__init__(self)
        Gtk.Paned.__init__(self)
        self._tabs = []
        self._split_view = False
        self._active_document = None
        
        # primary notebook
        self._notebook1 = self._create_notebook()
        self.add1(self._notebook1)
        
        # secondary notebook
        self._notebook2 = self._create_notebook()
        self._notebook2.hide()
        self.add2(self._notebook2)
        
    def close_tab(self, document):
        raise NotImplementedError
    
    def new_tab(self, document=None, set_active=False):
        """
        Create a new EditorTab and add it to the editor.
        """
        tab = EditorTab(document)

        if self._split_view is not False:    # split the view
            tab.split(self._split_view)
        
        # active document is set when a view is focused or page changed
        tab.connect("view-focused", self._on_view_focused)
        if not self._active_document:
            tab.grab_focus()
            
        self._add_tab(self._notebook1, tab)
        self.debug('"document-added" %s %s', tab.document.name, tab.document)
        self.emit("document-added", tab.document)
        
        if set_active:
            self.set_active_document(tab.document)
    
    def set_active_document(self, document):
        """
        Set the active document being edited and make sure it's notebook page
        is currently active.
        
        Args:
            document -- A `mykiss.Document` instance.
        """
        self._active_document = document
        # make sure it's notebook page is visible
        # TODO yuck! refactor this
        page = self._notebook1.get_nth_page(self._notebook1.get_current_page())
        if page and page.editor_tab.document != document:
            pagenum = 0
            for child in self._notebook1.get_children():
                print document, " vs ", child.editor_tab.document
                if child.editor_tab.document == document:
                    print pagenum
                    self._notebook1.set_current_page(pagenum)
                pagenum += 1
                    
        page = self._notebook2.get_nth_page(self._notebook2.get_current_page())
        if page and page.editor_tab.document != document:
            pagenum = 0
            for child in self._notebook2.get_children():
                if child.editor_tab.document == document:
                    self._notebook2.set_current_page(pagenum)
            pagenum += 1
        
        self.debug('"active-document-changed" %s %s', document.name, document)
        self.emit("active-document-changed", document)
    
    def get_active_document(self, document):
        """
        Return the active `mykiss.Document`.        
        """
        return self._active_document
        
    def split_editor(self, orientation=Gtk.Orientation.VERTICAL):
        """
        Split the Editor into 2 separate notebooks where the pages can be
        dragged from one pane to the other. 
        
        Args:
            orientation -- A Gtk.Orientation constant
        """
        # switch orientation since a user expects a "vertical" split to show
        # panes in the "horizontal" orientation
        if orientation == Gtk.Orientation.VERTICAL:
            self.set_orientation(Gtk.Orientation.HORIZONTAL)
        else:
            self.set_orientation(Gtk.Orientation.VERTICAL)
        self._notebook2.show()
    
    def split_view(self, orientation=Gtk.Orientation.VERTICAL):
        """
        Splits the view of the active document. See `EditorTab.split()`
        """
        self._split_view = orientation
        for tab in self._tabs:
            tab.split(orientation)
        
    def unsplit_editor(self):
        """
        Restore the Editor to a single pane merging all the notebook pages.
        """
        # TODO: move all pages to notebook1
        self._notebook2.hide()
        #for child in self._notebook2.get_children():
        #    self._notebook2.remove_child(child)
        #    self._add_view_to_notebook(self._notebook1, child
    
    def unsplit_view(self):
        """
        Restores a single view of the active document. See `EditorTab.unsplit()`
        """
        self._split_view = False
        for tab in self._tabs:
            tab.unsplit()
        
    def _add_tab(self, notebook, tab):
        """ Add the tab to the editor notebook. """
        self._tabs.append(tab)
        notebook.append_page(tab.page_widget, tab.tab_widget)
        notebook.set_tab_reorderable(tab.page_widget, True)
        notebook.set_tab_detachable(tab.page_widget, True)
        
    def _create_notebook(self):
        """ Return an Editor Gtk.Notebook . """
        notebook = Gtk.Notebook()
        notebook.show()
        notebook.set_group_name("Editor")
        notebook.set_scrollable(True)
        notebook.connect("switch-page", self._on_notebook_switch_page)
        return notebook
    
    def _on_notebook_switch_page(self, notebook, page, page_num):
        document = page.editor_tab.document
        if document != self._active_document:
            self.set_active_document(document)
    
    def _on_view_focused(self, editor_tab, view, document, data=None):
        if document != self._active_document:
            self.set_active_document(document)

class EditorTab(GObject.Object):
    __gsignals__ = {
        "view-focused": (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,(GObject.TYPE_PYOBJECT,GObject.TYPE_PYOBJECT,)),
    }
    untitled_counter = 0
    """
    Used by the `Editor` to manage the notebook pages containing a view.
    """
    def __init__(self, document=None):
        GObject.Object.__init__(self)
        self._document = document
        self._paned = Gtk.Paned()
        self._paned.show()
        self._view1 = None
        self._view2 = None
        
        if document:
            self._document = document
            # TODO get name from document?
            self._name = "TODO!"
        else:
            self._document = Document()
            EditorTab.untitled_counter += 1
            self._name = "Untitled %d" % EditorTab.untitled_counter
            self._document.set_name(self._name)
            
        
        # TODO create the complicated tab label widget
        self._tab_widget = Gtk.Label(self._name)
        
        sw, self._view1 = self._create_view()
        self._paned.add1(sw)
        
                
        #self._infobar = EditorInfobar()
        
        box = Gtk.VBox()
        box.pack_start(self._paned, True, True, 0)
        #box.pack_start(self._infobar, False, True, 0)
        box.show()
        
        self._page_widget = box
        # yuck, I don't like this. Let's create a widget for the page_widget
        self._page_widget.editor_tab = self 
    
    @GObject.property
    def document(self):
        return self._document
    
    @GObject.property
    def name(self):
        return self._name
        
    @GObject.property
    def tab_widget(self):
        return self._tab_widget
    
    @GObject.property
    def page_widget(self):
        return self._page_widget
    
    def grab_focus(self):
        self._view1.grab_focus()
        
    def split(self, orientation=Gtk.Orientation.VERTICAL):
        """
        Split the pane into 2 separate views of the same document which share
        a text buffer.
        
        Args:
            orientation -- A Gtk.Orientation constant
        """
        # switch orientation since a user expects a "vertical" split to show
        # panes in the "horizontal" orientation
        if orientation == Gtk.Orientation.VERTICAL:
            self._paned.set_orientation(Gtk.Orientation.HORIZONTAL)
        else:
            self._paned.set_orientation(Gtk.Orientation.VERTICAL)
        
        if not self._view2:
            sw, self._view2 = self._create_view(self._view1.get_buffer())
            self._paned.add2(sw)
        self._view2.get_parent().show()
        
    def unsplit(self):
        """
        Restore the view to a single pane.
        """
        # Cannot destroy the view once it's been created since it seems to 
        # destroy the buffer as well.
        self._view2.get_parent().hide()
        
    def _create_view(self, buffer=None):
        """ Return 2-tuple with the view widget and it's container. """
        view = View(buffer)
        view.show()
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        sw.set_shadow_type(Gtk.ShadowType.ETCHED_IN)
        sw.add(view)
        sw.show()
        
        view.connect("focus-in-event", self._on_view_focus)

        return (sw, view)
    
    def _on_view_focus(self, view, event, data=None):
        self.emit("view-focused", view, self._document)

class EditorInfobar(Gtk.Box):
    def __init__(self):
        Gtk.Box.__init__(self, Gtk.Orientation.HORIZONTAL)
        # dummy data
        self.set_spacing(10)
        label = Gtk.Label("file:///home/micah/Documents/Projects/mykiss/run_local.py")
        label.set_alignment(0.0, 0.5)
        label.set_ellipsize(Pango.EllipsizeMode.MIDDLE)
        self.pack_start(label, True, True, 2)
        label = Gtk.Label("Mime: text/python    Ln 13, Col 46    INS CAPS NUM")
        label.set_alignment(1.0, 0.5)
        self.pack_start(label, True, True, 2)
        self.show_all()
        
        
