from gi.repository import GObject, Gtk, Pango
from gi.repository import GtkSource
from mykiss import Document
from mykiss.widgets import TabLabel

class EditorTab(GObject.Object):
    __gsignals__ = {
        "view-focused": (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,
                        (GObject.TYPE_PYOBJECT,GObject.TYPE_PYOBJECT,)),
        "close-clicked":(GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,
                        (GObject.TYPE_PYOBJECT,)),
    }
    untitled_counter = 0
    """
    Used by the `Editor` to manage the notebook pages containing a view.
    """
    def __init__(self, document=None):
        GObject.Object.__init__(self)
        self._document = document
        self._paned = Gtk.Paned()
        self._paned.show()
        self._view1 = None
        self._view2 = None
        
        if document:
            self._document = document
            self._name = document.name
        else:
            self._document = Document()
            EditorTab.untitled_counter += 1
            self._name = "Untitled %d" % EditorTab.untitled_counter
            self._document.set_name(self._name)
        
        self._tab_widget = TabLabel(self._name)
        self._tab_widget.connect("close-clicked", self._on_close_clicked)
        
        # connect to signals to update state
        self._document.connect("read-start", self._on_document_busy)
        self._document.connect("read-complete", self._on_document_ready)
        
        self._buffer = GtkSource.Buffer() # create buffer before views
        sw, self._view1 = self._create_view()
        self._paned.add1(sw)

        box = Gtk.VBox()
        box.pack_start(self._paned, True, True, 0)
        #box.pack_start(self._infobar, False, True, 0)
        box.show()
        
        self._page_widget = box
        # yuck, I don't like this. Let's create a widget for the page_widget
        self._page_widget.editor_tab = self 
    
    @GObject.property
    def buffer(self):
        return self._buffer
    
    def get_buffer(self):
        return self._buffer
    
    @GObject.property
    def view1(self):
        return self._view1
    
    def get_view1(self):
        return self._view1
    
    @GObject.property
    def view2(self):
        return self._view2
    
    def get_view1(self):
        return self._view1
    
    def get_views(self):
        views = [self._view1,]
        if self._view2:
            views.append(self._view2)
        return views
        
    @GObject.property
    def document(self):
        return self._document
    
    def get_document(self):
        return self._document
        
    @GObject.property
    def name(self):
        return self._name
        
    @GObject.property
    def tab_widget(self):
        return self._tab_widget
    
    @GObject.property
    def page_widget(self):
        return self._page_widget
    
    def grab_focus(self):
        self._view1.grab_focus()
        
    def split(self, orientation=Gtk.Orientation.VERTICAL):
        """
        Split the pane into 2 separate views of the same document which share
        a text buffer.
        
        Args:
            orientation -- A Gtk.Orientation constant
        """
        # switch orientation since a user expects a "vertical" split to show
        # panes in the "horizontal" orientation
        if orientation == Gtk.Orientation.VERTICAL:
            self._paned.set_orientation(Gtk.Orientation.HORIZONTAL)
        else:
            self._paned.set_orientation(Gtk.Orientation.VERTICAL)
        
        if not self._view2:
            sw, self._view2 = self._create_view()
            self._paned.add2(sw)
        self._view2.get_parent().show()
        
    def unsplit(self):
        """
        Restore the view to a single pane.
        """
        # Cannot destroy the view once it's been created since it seems to 
        # destroy the buffer as well.
        self._view2.get_parent().hide()
        
    def _create_view(self):
        """ Return 2-tuple with the view widget and it's container. """
        view = GtkSource.View.new_with_buffer(self._buffer)
        view.show()
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        sw.set_shadow_type(Gtk.ShadowType.ETCHED_IN)
        sw.add(view)
        sw.show()
        
        view.connect("focus-in-event", self._on_view_focus)

        return (sw, view)
    
    def _on_view_focus(self, view, event, data=None):
        self.emit("view-focused", view, self._document)
    
    def _on_close_clicked(self, tab_label, data=None):
        self.emit("close-clicked", self._document)
    
    def _on_document_busy(self, document, data=None):
        self._tab_widget.set_busy(True)
        # how is this done with GTK3?
        # view.get_window(gtk.TEXT_WINDOW_WIDGET).set_cursor(gtk.gdk.Cursor(gtk.gdk.WATCH))
        while Gtk.events_pending():
            Gtk.main_iteration()
    
    def _on_document_ready(self, document, data=None):
        self._tab_widget.set_busy(False)
