import sys
import os
from gi.repository import GLib
from gi.repository import GObject
from gettext import gettext as _
from mykiss.logobject import LogObject

default_plugin_engine = None

class ValidationError(Exception):
    """
    Exception class for validation errors in plugin info files.
    
    Args:
        msg: The error message.
        filename: The name of the invalid file. 
    """
    def __init__(self, msg, filename=None):
        if filename:
            Exception.__init__(self, "%s in %s" % (msg, filename))
        else:
            Exception.__init__(self, msg)

class PluginInfo(object):
    """
    Information about a plugin as defined in a key/value file.
    
    Args:
        plugin_file: See parse_plugin_file()
    
    Raises:
        ValidationError: The plugin key/value file is invalid.
    """
    def __init__(self, plugin_file):
        self._required_keys = ('name', 'version', 'module')
        if plugin_file:
            self.parse_plugin_file(plugin_file)
    
    def parse_plugin_file(self, plugin_file):
        """
        Parse the plugin information file and map the key names and values to
        class attributes. 
        
        Arguments:
            plugin_file: Full path to the plugin info key/value file.
        
        Raises:
            ValidationError: The plugin key/value file is invalid.
        """
        self.plugin_file = plugin_file
        # TODO: KeyFile is broken in GLib 2.30. Use config parser or ini file (xdg)
        parser = GLib.KeyFile()
        parser.load_from_file(plugin_file, GLib.KeyFileFlags.NONE)
        if not parser.has_group("Plugin"):
            raise ValidationError(_("Missing 'Plugin' group."))
        for key in parser.get_keys("Plugin")[0]:
            setattr(self, key, parser.get_string("Plugin", key))
        for key in self._required_keys:
            try:
                getattr(self, key)
            except AttributeError:
                raise ValidationError(_("Missing required key: '%s'") % key,
                                      plugin_file)
                                      
        # convert version to a list of integers for easy version comparison
        self.version_string = self.version
        try:
            self.version = [int(value) for value in self.version.split(".")]
            self.version = (self.version + [0] * 3)[:3] # pad with 0
        except ValueError:
            raise ValidationError(_("Invalid format for key: 'version'"), plugin_file)

class PluginEngine(GObject.Object, LogObject):
    __gtype_name__ = 'PluginEngine'
    """
    Plugin Engine
    
    The MyKiss plugin engine.
    """
    def __init__(self):
        GObject.Object.__init__(self)
        self.init_logging()
        self._plugin_dirs = []
        self._enabled_plugins = []
    
    @GObject.property
    def plugin_dirs(self):
        return self._plugin_dirs
    
    @GObject.property
    def enabled_plugins(self):
        return self._enabled_plugins
        
    def add_plugin_dir(self, path):
        """
        Add 'path' to the list of directories to scan for plugins and also add
        to sys.path so that the plugin(s) can be imported.
        
        Args:
            path: Full path to the directory containing plugins. 
        """
        if path not in sys.path:
            sys.path.append(path)
            
        if path not in self._plugin_dirs:
            self._plugin_dirs.append(path)
    
    def get_plugin_info(self, plugin_name):
        """
        Return a PluginInfo object for the plugin or None if the plugin file
        is not found in any of the "plugin_dirs". If the same plugin is found in 
        multiple directories, return a PluginInfo for the plugin the highest 
        version number.
        
        Args:
            plugin_name: The plugin name corresponding to the name of the 
                 .plugin file. Eg, "foobar.plugin" would be "foobar".
        """
        found_plugins = []
        for path in self._plugin_dirs:
            plugin_file = os.path.join(path, plugin_name + ".plugin")
            if os.path.exists(plugin_file):
                info = PluginInfo(plugin_file)
                found_plugins.append(info)
        if not found_plugins:
            return None
        elif len(found_plugins) == 1:
            return found_plugins[0]
        
        # version comparison
        plugin_info = found_plugins[0]
        for info in found_plugins:
            if info.version[0] > plugin_info.version[0]:
                plugin_info = info
            elif info.version[0] == plugin_info.version[0]:
                if info.version[1] > plugin_info.version[1]:
                    plugin_info = info
                elif info.version[1] == plugin_info.version[1]:
                    if info.version[2] > plugin_info.version[2]:
                        plugin_info = info
        return plugin_info
        
    def set_enabled_plugins(self, plugin_names):
        """
        Set the list of enabled plugins. If a plugin that has already been 
        activated is not in the new list then it will be deactivated.
        
        Args:
            plugin_names: A list or tuple of plugin names corresponding to the
                name of the .plugin file. Eg, "foobar.plugin" would be "foobar".
        """
        self._enabled_plugins = []
        # TODO deactivate plugins if replacing the list
        for name in plugin_names:
            try:
                info = self.get_plugin_info(name)
            except ValidationError, e:
                self.warning(e)
                continue
            if not info:
                self.warning(_("Plugin not found: %s"), name)
                continue
            self.debug(_("Enabling '%s' from %s") % (info.name, info.plugin_file))
            self._enabled_plugins.append(info)

def get_default_plugin_engine():
    """
    Return the default instance of the plugin engine.
    """
    global default_plugin_engine
    if not default_plugin_engine:
        default_plugin_engine = PluginEngine()
    return default_plugin_engine

"""
    name = "terminal"
    activation = "WindowPlugin"
    info = __import__("plugins."+name, globals(), locals(), ['name', 'module'], -1)
    print info.name
    module = __import__("plugins."+name+"."+info.module, globals(), locals(), ['Plugin'], -1)
    from plugin import WindowPlugin
    for plugin_class in WindowPlugin.__subclasses__():
        plugin = plugin_class()
        plugin.window = self
        plugin.do_activate()
"""
