import locale
from gi.repository import GObject, Gio, Gtk, GLib
from gi.repository import GtkSource
from mykiss.icons import first_available_icon_name
from mykiss import LogObject

class InvalidStateError(Exception):
    pass
    
class Document(GObject.Object, LogObject):
    STATE_NORMAL = 0
    STATE_READING = 1
    STATE_SAVING = 2
    __gsignals__ = {
        "read-start":     (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,
                          (GObject.TYPE_PYOBJECT,)),
        "read-complete":  (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,
                          (GObject.TYPE_PYOBJECT,)),
        "info-changed":   (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE,
                          ()),
    }
    def __init__(self, uri=None):
        GObject.Object.__init__(self)
        LogObject.__init__(self)
        self._file = None
        self._name = "Untitled"
        self._mime_type = "text/plain"
        self._icon_name = Gtk.STOCK_FILE
        self._encoding = "UTF-8"
        self._cancellable = Gio.Cancellable()
        self._language = None
        self._state = Document.STATE_NORMAL
        
        if uri:
            self.set_file_from_uri(uri)
    
    def get_file(self):
        return self._file
    
    def set_file(self, giofile):
        self._file = giofile
        self._name = self._file.get_basename()
        self._query_info()
        self.debug('"info-changed" %s', self._name)
        self.emit("info-changed")

    def set_file_from_uri(self, uri):
        giofile = Gio.File.new_for_uri(uri)
        self.set_file(giofile)

    @GObject.property
    def name(self):
        return self._name
    
    def get_name(self):
        return self._name
    
    def set_name(self, name):
        self._name = name
        
    @GObject.property
    def mime_type(self):
        return self._mime_type
    
    def get_mime_type(self):
        return self._mime_type
    
    @GObject.property
    def icon_name(self):
        return self._icon_name
    
    def get_icon_name(self):
        return self._icon_name
    
    def get_encoding(self):
        return self._encoding
    
    def set_encoding(self, encoding):
        if self._encoding != encoding:
            self._encoding = encoding
            self.debug('"info-changed" %s', self._name)
            self.emit("info-changed")
        
    def set_language(self, language):
        # should we only store the language_id?
        self._language = language
    
    def get_language_name(self):
        if self._language:
            return self._language.get_name()
        else:
            return "Plain Text"
    
    def is_normal_state(self):
        return (self._state == Document.STATE_NORMAL)
        
    def is_reading(self):
        if self._state == Document.STATE_READING:
            return True
        return False
        
    def read(self, buffer):
        """
        Begins the asynchronous loading of the file into the text buffer. 
        
        Args:
            buffer            -- A Gtk.SourceBuffer in which to load the file.
        
        Raises:
            InvalidStateError -- The document is already performing an async
                                 operation. Make sure document is in the normal
                                 state.
        """
        if not self.is_normal_state():
            raise InvalidStateError
        # Cannot use Gio.InputStream.read_async() in Python prior to GLib 2.33.2
        # http://git.gnome.org/browse/glib/commit/?id=800d6ff1115b27bf0e9cce818a0511048e2f1cc5
        
        # TODO: what if it's read only?
        if self._language:
            buffer.set_language(self._language)
        self._cancellable.reset()
        self._state = Document.STATE_READING
        buffer.begin_not_undoable_action()
        buffer.set_text("")
        self.debug('"read-start" %s', self._file.get_uri())
        self.emit("read-start", buffer)
        self._file.load_contents_async(None, self._load_contents_async_cb, buffer)     
        
    def _load_contents_async_cb(self, giofile, result, buffer):
        """ Callback from `Gio.File.load_contents_async()`. """
        success, contents, etag = giofile.load_contents_finish(result)
        self._bytes = len(contents)
        
        # TODO: nl_langinfo "This function is not available on all systems"
        found_encoding = False
        encodings = ['UTF-8', 'ISO-8859-15', 'UTF-16']
        locencoding = locale.nl_langinfo(locale.CODESET)
        if not locencoding in encodings:
            encodings.append(locencoding)
        for encoding in encodings:
            try:
                decoded = contents.decode(encoding)
                buffer.set_text(decoded)
                if encoding != self._encoding:
                    self.set_encoding(encoding) # emits "info-changed"
                found_encoding = True
                self.debug('"read-complete" %s', self._file.get_uri())
                self.emit("read-complete", buffer)
                break
            except UnicodeDecodeError:
                pass
        
        if not found_encoding:
            print "'read-failed'"
            self._encoding = "UTF-8"
        
        buffer.end_not_undoable_action()
        self._state = Document.STATE_NORMAL

    def _query_info(self):
        """ Query information from the Gio.File. """
        info = self._file.query_info('standard::icon,'
                                     'standard::fast-content-type,'
                                     'access::can-read,'
                                     'access::can-write',
                                     0, None)
        self._icon_name = first_available_icon_name(info.get_icon().get_names(),
                                                    Gtk.STOCK_FILE)
        self._mime_type = info.get_attribute_string(Gio.FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE)
        if not self._mime_type:
            self._mime_type = "text/plain"
        
        # set language based on mime-type
        manager = GtkSource.LanguageManager.get_default()
        self.set_language(manager.guess_language(None, self._mime_type))

        return info
